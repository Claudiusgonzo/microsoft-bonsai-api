/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package microsoft.bonsai.simulatorapi.implementation;

import retrofit2.Retrofit;
import microsoft.bonsai.simulatorapi.Simulators;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import microsoft.bonsai.simulatorapi.models.Event;
import microsoft.bonsai.simulatorapi.models.ProblemDetails;
import microsoft.bonsai.simulatorapi.models.SimulatorInterface;
import microsoft.bonsai.simulatorapi.models.SimulatorList;
import microsoft.bonsai.simulatorapi.models.SimulatorState;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Simulators.
 */
public class SimulatorsImpl implements Simulators {
    /** The Retrofit service to perform REST calls. */
    private SimulatorsService service;
    /** The service client containing this operation class. */
    private SimulatorAPIImpl client;

    /**
     * Initializes an instance of Simulators.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SimulatorsImpl(Retrofit retrofit, SimulatorAPIImpl client) {
        this.service = retrofit.create(SimulatorsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Simulators to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SimulatorsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.Simulators listSimulators" })
        @GET("v2/workspaces/{workspaceName}/simulators")
        Observable<Response<ResponseBody>> listSimulators(@Path("workspaceName") String workspaceName, @Query("deployment_mode") String deploymentMode);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.Simulators registerSimulator" })
        @PUT("v2/workspaces/{workspaceName}/simulators")
        Observable<Response<ResponseBody>> registerSimulator(@Path("workspaceName") String workspaceName, @Body SimulatorInterface registrationInfo);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.Simulators getMostRecentAction" })
        @GET("v2/workspaces/{workspaceName}/simulators/{sessionIdString}")
        Observable<Response<ResponseBody>> getMostRecentAction(@Path("workspaceName") String workspaceName, @Path("sessionIdString") String sessionIdString);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.Simulators advance" })
        @POST("v2/workspaces/{workspaceName}/simulators/{sessionIdString}")
        Observable<Response<ResponseBody>> advance(@Path("workspaceName") String workspaceName, @Path("sessionIdString") String sessionIdString, @Body SimulatorState state);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.Simulators deregisterSimulator" })
        @HTTP(path = "v2/workspaces/{workspaceName}/simulators/{sessionIdString}", method = "DELETE", hasBody = true)
        @Streaming
        Observable<Response<ResponseBody>> deregisterSimulator(@Path("workspaceName") String workspaceName, @Path("sessionIdString") String sessionIdString);

    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSimulators(String workspaceName) {
        return listSimulatorsWithServiceResponseAsync(workspaceName).toBlocking().single().body();
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSimulatorsAsync(String workspaceName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSimulatorsWithServiceResponseAsync(workspaceName), serviceCallback);
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSimulatorsAsync(String workspaceName) {
        return listSimulatorsWithServiceResponseAsync(workspaceName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSimulatorsWithServiceResponseAsync(String workspaceName) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        final String deploymentMode = null;
        return service.listSimulators(workspaceName, deploymentMode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSimulatorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSimulators(String workspaceName, String deploymentMode) {
        return listSimulatorsWithServiceResponseAsync(workspaceName, deploymentMode).toBlocking().single().body();
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSimulatorsAsync(String workspaceName, String deploymentMode, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSimulatorsWithServiceResponseAsync(workspaceName, deploymentMode), serviceCallback);
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSimulatorsAsync(String workspaceName, String deploymentMode) {
        return listSimulatorsWithServiceResponseAsync(workspaceName, deploymentMode).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementaton of the GET /v2/.../simulators endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulators?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSimulatorsWithServiceResponseAsync(String workspaceName, String deploymentMode) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        return service.listSimulators(workspaceName, deploymentMode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSimulatorsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSimulatorsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SimulatorList>() { }.getType())
                .register(400, new TypeToken<ProblemDetails>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the PUT /v2/.../simulators endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Event object if successful.
     */
    public Event registerSimulator(String workspaceName, SimulatorInterface registrationInfo) {
        return registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo).toBlocking().single().body();
    }

    /**
     * Implementation of the PUT /v2/.../simulators endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Event> registerSimulatorAsync(String workspaceName, SimulatorInterface registrationInfo, final ServiceCallback<Event> serviceCallback) {
        return ServiceFuture.fromResponse(registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo), serviceCallback);
    }

    /**
     * Implementation of the PUT /v2/.../simulators endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<Event> registerSimulatorAsync(String workspaceName, SimulatorInterface registrationInfo) {
        return registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo).map(new Func1<ServiceResponse<Event>, Event>() {
            @Override
            public Event call(ServiceResponse<Event> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the PUT /v2/.../simulators endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<ServiceResponse<Event>> registerSimulatorWithServiceResponseAsync(String workspaceName, SimulatorInterface registrationInfo) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (registrationInfo == null) {
            throw new IllegalArgumentException("Parameter registrationInfo is required and cannot be null.");
        }
        Validator.validate(registrationInfo);
        return service.registerSimulator(workspaceName, registrationInfo)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Event>>>() {
                @Override
                public Observable<ServiceResponse<Event>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Event> clientResponse = registerSimulatorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Event> registerSimulatorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Event, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Event>() { }.getType())
                .register(400, new TypeToken<Event>() { }.getType())
                .register(500, new TypeToken<Event>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the GET /v2/.../simulators/{sessionId} endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Event object if successful.
     */
    public Event getMostRecentAction(String workspaceName, String sessionIdString) {
        return getMostRecentActionWithServiceResponseAsync(workspaceName, sessionIdString).toBlocking().single().body();
    }

    /**
     * Implementation of the GET /v2/.../simulators/{sessionId} endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identification of the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Event> getMostRecentActionAsync(String workspaceName, String sessionIdString, final ServiceCallback<Event> serviceCallback) {
        return ServiceFuture.fromResponse(getMostRecentActionWithServiceResponseAsync(workspaceName, sessionIdString), serviceCallback);
    }

    /**
     * Implementation of the GET /v2/.../simulators/{sessionId} endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<Event> getMostRecentActionAsync(String workspaceName, String sessionIdString) {
        return getMostRecentActionWithServiceResponseAsync(workspaceName, sessionIdString).map(new Func1<ServiceResponse<Event>, Event>() {
            @Override
            public Event call(ServiceResponse<Event> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the GET /v2/.../simulators/{sessionId} endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<ServiceResponse<Event>> getMostRecentActionWithServiceResponseAsync(String workspaceName, String sessionIdString) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionIdString == null) {
            throw new IllegalArgumentException("Parameter sessionIdString is required and cannot be null.");
        }
        return service.getMostRecentAction(workspaceName, sessionIdString)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Event>>>() {
                @Override
                public Observable<ServiceResponse<Event>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Event> clientResponse = getMostRecentActionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Event> getMostRecentActionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Event, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Event>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the POST /v2/.../simulators/{sessionId}
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Event object if successful.
     */
    public Event advance(String workspaceName, String sessionIdString, SimulatorState state) {
        return advanceWithServiceResponseAsync(workspaceName, sessionIdString, state).toBlocking().single().body();
    }

    /**
     * Implementation of the POST /v2/.../simulators/{sessionId}
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Event> advanceAsync(String workspaceName, String sessionIdString, SimulatorState state, final ServiceCallback<Event> serviceCallback) {
        return ServiceFuture.fromResponse(advanceWithServiceResponseAsync(workspaceName, sessionIdString, state), serviceCallback);
    }

    /**
     * Implementation of the POST /v2/.../simulators/{sessionId}
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<Event> advanceAsync(String workspaceName, String sessionIdString, SimulatorState state) {
        return advanceWithServiceResponseAsync(workspaceName, sessionIdString, state).map(new Func1<ServiceResponse<Event>, Event>() {
            @Override
            public Event call(ServiceResponse<Event> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the POST /v2/.../simulators/{sessionId}
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<ServiceResponse<Event>> advanceWithServiceResponseAsync(String workspaceName, String sessionIdString, SimulatorState state) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionIdString == null) {
            throw new IllegalArgumentException("Parameter sessionIdString is required and cannot be null.");
        }
        if (state == null) {
            throw new IllegalArgumentException("Parameter state is required and cannot be null.");
        }
        Validator.validate(state);
        return service.advance(workspaceName, sessionIdString, state)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Event>>>() {
                @Override
                public Observable<ServiceResponse<Event>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Event> clientResponse = advanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Event> advanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Event, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Event>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the InputStream object if successful.
     */
    public InputStream deregisterSimulator(String workspaceName, String sessionIdString) {
        return deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionIdString).toBlocking().single().body();
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString The session ID generated during registration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<InputStream> deregisterSimulatorAsync(String workspaceName, String sessionIdString, final ServiceCallback<InputStream> serviceCallback) {
        return ServiceFuture.fromResponse(deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionIdString), serviceCallback);
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<InputStream> deregisterSimulatorAsync(String workspaceName, String sessionIdString) {
        return deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionIdString).map(new Func1<ServiceResponse<InputStream>, InputStream>() {
            @Override
            public InputStream call(ServiceResponse<InputStream> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionIdString The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the InputStream object
     */
    public Observable<ServiceResponse<InputStream>> deregisterSimulatorWithServiceResponseAsync(String workspaceName, String sessionIdString) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionIdString == null) {
            throw new IllegalArgumentException("Parameter sessionIdString is required and cannot be null.");
        }
        return service.deregisterSimulator(workspaceName, sessionIdString)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<InputStream>>>() {
                @Override
                public Observable<ServiceResponse<InputStream>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<InputStream> clientResponse = deregisterSimulatorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<InputStream> deregisterSimulatorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<InputStream, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<InputStream>() { }.getType())
                .build(response);
    }

}

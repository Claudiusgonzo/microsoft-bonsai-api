/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package microsoft.bonsai.simulatorapi.implementation;

import retrofit2.Retrofit;
import microsoft.bonsai.simulatorapi.SimulatorSessions;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import microsoft.bonsai.simulatorapi.models.Event;
import microsoft.bonsai.simulatorapi.models.ProblemDetails;
import microsoft.bonsai.simulatorapi.models.SimulatorInterface;
import microsoft.bonsai.simulatorapi.models.SimulatorSession;
import microsoft.bonsai.simulatorapi.models.SimulatorSessionSummary;
import microsoft.bonsai.simulatorapi.models.SimulatorState;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in SimulatorSessions.
 */
public class SimulatorSessionsImpl implements SimulatorSessions {
    /** The Retrofit service to perform REST calls. */
    private SimulatorSessionsService service;
    /** The service client containing this operation class. */
    private SimulatorAPIImpl client;

    /**
     * Initializes an instance of SimulatorSessions.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SimulatorSessionsImpl(Retrofit retrofit, SimulatorAPIImpl client) {
        this.service = retrofit.create(SimulatorSessionsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for SimulatorSessions to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SimulatorSessionsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions listSessions" })
        @GET("v2/workspaces/{workspaceName}/simulatorSessions")
        Observable<Response<ResponseBody>> listSessions(@Path("workspaceName") String workspaceName, @Query("deployment_mode") String deploymentMode, @Query("session_status") String sessionStatus, @Query("collection") String collection, @Query("package") String packageParameter);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions registerSimulator" })
        @POST("v2/workspaces/{workspaceName}/simulatorSessions")
        Observable<Response<ResponseBody>> registerSimulator(@Path("workspaceName") String workspaceName, @Body SimulatorInterface registrationInfo);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions describeOneSession" })
        @GET("v2/workspaces/{workspaceName}/simulatorSessions/{sessionId}")
        Observable<Response<ResponseBody>> describeOneSession(@Path("workspaceName") String workspaceName, @Path("sessionId") String sessionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions deregisterSimulator" })
        @HTTP(path = "v2/workspaces/{workspaceName}/simulatorSessions/{sessionId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deregisterSimulator(@Path("workspaceName") String workspaceName, @Path("sessionId") String sessionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions getMostRecentAction" })
        @GET("v2/workspaces/{workspaceName}/simulatorSessions/{sessionId}/action")
        Observable<Response<ResponseBody>> getMostRecentAction(@Path("workspaceName") String workspaceName, @Path("sessionId") String sessionId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: microsoft.bonsai.simulatorapi.SimulatorSessions advance" })
        @POST("v2/workspaces/{workspaceName}/simulatorSessions/{sessionId}/advance")
        Observable<Response<ResponseBody>> advance(@Path("workspaceName") String workspaceName, @Path("sessionId") String sessionId, @Body SimulatorState state);

    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSessions(String workspaceName) {
        return listSessionsWithServiceResponseAsync(workspaceName).toBlocking().single().body();
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSessionsAsync(String workspaceName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSessionsWithServiceResponseAsync(workspaceName), serviceCallback);
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSessionsAsync(String workspaceName) {
        return listSessionsWithServiceResponseAsync(workspaceName).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSessionsWithServiceResponseAsync(String workspaceName) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        final String deploymentMode = null;
        final String sessionStatus = null;
        final String collection = null;
        final String packageParameter = null;
        return service.listSessions(workspaceName, deploymentMode, sessionStatus, collection, packageParameter)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSessionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @param sessionStatus A specifier to filter on session status
     * @param collection If present, only sessions in this collection
     * @param packageParameter If present, only sessions in this package
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object listSessions(String workspaceName, String deploymentMode, String sessionStatus, String collection, String packageParameter) {
        return listSessionsWithServiceResponseAsync(workspaceName, deploymentMode, sessionStatus, collection, packageParameter).toBlocking().single().body();
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @param sessionStatus A specifier to filter on session status
     * @param collection If present, only sessions in this collection
     * @param packageParameter If present, only sessions in this package
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> listSessionsAsync(String workspaceName, String deploymentMode, String sessionStatus, String collection, String packageParameter, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(listSessionsWithServiceResponseAsync(workspaceName, deploymentMode, sessionStatus, collection, packageParameter), serviceCallback);
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @param sessionStatus A specifier to filter on session status
     * @param collection If present, only sessions in this collection
     * @param packageParameter If present, only sessions in this package
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> listSessionsAsync(String workspaceName, String deploymentMode, String sessionStatus, String collection, String packageParameter) {
        return listSessionsWithServiceResponseAsync(workspaceName, deploymentMode, sessionStatus, collection, packageParameter).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions endpoint.
     * Retrieves all of the simulators currently registered with all
     simulator gateways within this workspace.
     The deployment_mode appears in the query string. It can be one of
     Unspecified, Testing, or Hosted. If it has a 'neq:' prefix, that means "not;"
     e.g., .../simulatorSessions?deployment_mode=neq:Hosted means the response should not include
     simulators that are hosted.
     The session_status can be one of Attachable, Attached, Detaching, Rejected,
     and supports the neq: prefix.
     The collection appears in the query string
     The package appears in the query string
     The filter queries can appear together, like
     .../simulatorSessions?deployment_mode=Hosted&amp;collection=1234-455-33333.
     *
     * @param workspaceName The workspace identifier.
     * @param deploymentMode A specifier to filter on deployment mode
     * @param sessionStatus A specifier to filter on session status
     * @param collection If present, only sessions in this collection
     * @param packageParameter If present, only sessions in this package
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> listSessionsWithServiceResponseAsync(String workspaceName, String deploymentMode, String sessionStatus, String collection, String packageParameter) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        return service.listSessions(workspaceName, deploymentMode, sessionStatus, collection, packageParameter)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = listSessionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> listSessionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<SimulatorSessionSummary>>() { }.getType())
                .register(400, new TypeToken<ProblemDetails>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object registerSimulator(String workspaceName, SimulatorInterface registrationInfo) {
        return registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo).toBlocking().single().body();
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> registerSimulatorAsync(String workspaceName, SimulatorInterface registrationInfo, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo), serviceCallback);
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> registerSimulatorAsync(String workspaceName, SimulatorInterface registrationInfo) {
        return registerSimulatorWithServiceResponseAsync(workspaceName, registrationInfo).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions endpoint.
     * Registers a simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param registrationInfo Information and capabilities about the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> registerSimulatorWithServiceResponseAsync(String workspaceName, SimulatorInterface registrationInfo) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (registrationInfo == null) {
            throw new IllegalArgumentException("Parameter registrationInfo is required and cannot be null.");
        }
        Validator.validate(registrationInfo);
        return service.registerSimulator(workspaceName, registrationInfo)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = registerSimulatorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> registerSimulatorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<SimulatorSession>() { }.getType())
                .register(400, new TypeToken<ProblemDetails>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions/{sessionId} endpoint.
     * Retrieves a simulator session corresponding to the sessionId.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The sessionId of the simulator session to fetch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object describeOneSession(String workspaceName, String sessionId) {
        return describeOneSessionWithServiceResponseAsync(workspaceName, sessionId).toBlocking().single().body();
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions/{sessionId} endpoint.
     * Retrieves a simulator session corresponding to the sessionId.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The sessionId of the simulator session to fetch
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> describeOneSessionAsync(String workspaceName, String sessionId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(describeOneSessionWithServiceResponseAsync(workspaceName, sessionId), serviceCallback);
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions/{sessionId} endpoint.
     * Retrieves a simulator session corresponding to the sessionId.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The sessionId of the simulator session to fetch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> describeOneSessionAsync(String workspaceName, String sessionId) {
        return describeOneSessionWithServiceResponseAsync(workspaceName, sessionId).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementaton of the GET /v2/.../simulatorSessions/{sessionId} endpoint.
     * Retrieves a simulator session corresponding to the sessionId.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The sessionId of the simulator session to fetch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> describeOneSessionWithServiceResponseAsync(String workspaceName, String sessionId) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        return service.describeOneSession(workspaceName, sessionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = describeOneSessionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> describeOneSessionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<SimulatorSession>() { }.getType())
                .register(400, new TypeToken<ProblemDetails>() { }.getType())
                .register(404, new TypeToken<ProblemDetails>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProblemDetails object if successful.
     */
    public ProblemDetails deregisterSimulator(String workspaceName, String sessionId) {
        return deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionId).toBlocking().single().body();
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The session ID generated during registration
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProblemDetails> deregisterSimulatorAsync(String workspaceName, String sessionId, final ServiceCallback<ProblemDetails> serviceCallback) {
        return ServiceFuture.fromResponse(deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionId), serviceCallback);
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProblemDetails object
     */
    public Observable<ProblemDetails> deregisterSimulatorAsync(String workspaceName, String sessionId) {
        return deregisterSimulatorWithServiceResponseAsync(workspaceName, sessionId).map(new Func1<ServiceResponse<ProblemDetails>, ProblemDetails>() {
            @Override
            public ProblemDetails call(ServiceResponse<ProblemDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the DELETE /v2/.../simulators endpoint.
     * Unregisters the simulator with the simulator gateway.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId The session ID generated during registration
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProblemDetails object
     */
    public Observable<ServiceResponse<ProblemDetails>> deregisterSimulatorWithServiceResponseAsync(String workspaceName, String sessionId) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        return service.deregisterSimulator(workspaceName, sessionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProblemDetails>>>() {
                @Override
                public Observable<ServiceResponse<ProblemDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProblemDetails> clientResponse = deregisterSimulatorDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProblemDetails> deregisterSimulatorDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ProblemDetails, RestException>newInstance(this.client.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<ProblemDetails>() { }.getType())
                .register(404, new TypeToken<ProblemDetails>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the GET /v2/.../simulatorSessions/{sessionId}/action endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Event object if successful.
     */
    public Event getMostRecentAction(String workspaceName, String sessionId) {
        return getMostRecentActionWithServiceResponseAsync(workspaceName, sessionId).toBlocking().single().body();
    }

    /**
     * Implementation of the GET /v2/.../simulatorSessions/{sessionId}/action endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identification of the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Event> getMostRecentActionAsync(String workspaceName, String sessionId, final ServiceCallback<Event> serviceCallback) {
        return ServiceFuture.fromResponse(getMostRecentActionWithServiceResponseAsync(workspaceName, sessionId), serviceCallback);
    }

    /**
     * Implementation of the GET /v2/.../simulatorSessions/{sessionId}/action endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<Event> getMostRecentActionAsync(String workspaceName, String sessionId) {
        return getMostRecentActionWithServiceResponseAsync(workspaceName, sessionId).map(new Func1<ServiceResponse<Event>, Event>() {
            @Override
            public Event call(ServiceResponse<Event> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the GET /v2/.../simulatorSessions/{sessionId}/action endpoint.
     * Gets the most recent action sent to the simulator to process.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identification of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<ServiceResponse<Event>> getMostRecentActionWithServiceResponseAsync(String workspaceName, String sessionId) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        return service.getMostRecentAction(workspaceName, sessionId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Event>>>() {
                @Override
                public Observable<ServiceResponse<Event>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Event> clientResponse = getMostRecentActionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Event> getMostRecentActionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Event, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Event>() { }.getType())
                .build(response);
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions/{sessionId}/advance
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Event object if successful.
     */
    public Event advance(String workspaceName, String sessionId, SimulatorState state) {
        return advanceWithServiceResponseAsync(workspaceName, sessionId, state).toBlocking().single().body();
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions/{sessionId}/advance
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Event> advanceAsync(String workspaceName, String sessionId, SimulatorState state, final ServiceCallback<Event> serviceCallback) {
        return ServiceFuture.fromResponse(advanceWithServiceResponseAsync(workspaceName, sessionId, state), serviceCallback);
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions/{sessionId}/advance
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<Event> advanceAsync(String workspaceName, String sessionId, SimulatorState state) {
        return advanceWithServiceResponseAsync(workspaceName, sessionId, state).map(new Func1<ServiceResponse<Event>, Event>() {
            @Override
            public Event call(ServiceResponse<Event> response) {
                return response.body();
            }
        });
    }

    /**
     * Implementation of the POST /v2/.../simulatorSessions/{sessionId}/advance
     endpoint.
     *
     * @param workspaceName The workspace identifier.
     * @param sessionId Unique identifier for the simulator.
     * @param state The new state of the simulator.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Event object
     */
    public Observable<ServiceResponse<Event>> advanceWithServiceResponseAsync(String workspaceName, String sessionId, SimulatorState state) {
        if (workspaceName == null) {
            throw new IllegalArgumentException("Parameter workspaceName is required and cannot be null.");
        }
        if (sessionId == null) {
            throw new IllegalArgumentException("Parameter sessionId is required and cannot be null.");
        }
        if (state == null) {
            throw new IllegalArgumentException("Parameter state is required and cannot be null.");
        }
        Validator.validate(state);
        return service.advance(workspaceName, sessionId, state)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Event>>>() {
                @Override
                public Observable<ServiceResponse<Event>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Event> clientResponse = advanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Event> advanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Event, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Event>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
